import torch
import librosa
import numpy as np
import mir_eval


WINDOW_SIZE = 256
HOP_LENGTH = 128

# this array is generated by `aver_magnitude` function
# with default values
#AVER_MAG = aver_magnitude()
AVER_MAG = np.array([0.85039094, 1.27376924, 1.41474296, 1.20514109, 1.23176826,
       1.47398962, 1.98643802, 2.13798647, 1.78847859, 1.43007457,
       1.44720347, 1.6135289 , 1.74149053, 1.82090986, 1.86734167,
       1.86888998, 1.79347349, 1.58919812, 1.46311885, 1.36981601,
       1.20240664, 1.11809345, 1.03610428, 0.94887941, 0.86127856,
       0.77033791, 0.69353176, 0.63642473, 0.59461861, 0.55332843,
       0.51090163, 0.47458099, 0.47116146, 0.46130326, 0.42584193,
       0.40715721, 0.3960142 , 0.38640094, 0.36634542, 0.36441523,
       0.36064543, 0.35144958, 0.34915805, 0.34405735, 0.33865032,
       0.33244192, 0.35141706, 0.37495401, 0.33562479, 0.32408034,
       0.32142437, 0.32502517, 0.32189844, 0.31364626, 0.30251861,
       0.30226354, 0.30522932, 0.29198097, 0.28294102, 0.279359  ,
       0.2727745 , 0.26783464, 0.26037925, 0.25916431, 0.25198149,
       0.2467505 , 0.2387767 , 0.22866348, 0.22944809, 0.23215027,
       0.22630396, 0.22428322, 0.22153575, 0.22184512, 0.23558603,
       0.25792853, 0.24151158, 0.2284713 , 0.23089213, 0.23258509,
       0.23540188, 0.23523662, 0.23095517, 0.22542835, 0.22214336,
       0.22002404, 0.22138502, 0.22012124, 0.21393916, 0.20786515,
       0.20026485, 0.19406063, 0.19179127, 0.19249558, 0.19072822,
       0.18541644, 0.18130259, 0.1777441 , 0.17605042, 0.17303351,
       0.17206202, 0.17247105, 0.17239889, 0.16970829, 0.16739554,
       0.16704435, 0.16673224, 0.16609053, 0.16555187, 0.16490034,
       0.16427763, 0.16382125, 0.16177368, 0.1575705 , 0.15213914,
       0.14841936, 0.14449395, 0.14214196, 0.13795736, 0.13400847,
       0.13067236, 0.12743451, 0.12458376, 0.12149144, 0.11780487,
       0.11494659, 0.11241502, 0.10979936, 0.09793014])


def istft(data, mask, data_len):
    """inverse stft."""
    batch, feature, seq = data.shape
    arr = data[:, :feature // 2] + 1j * data[:, feature // 2:]
    mask_len = mask.sum(1).astype('int')
    raw_seqs = [librosa.istft(arr[i, :, :mask_len[i]],
                              hop_length=HOP_LENGTH,
                              win_length=WINDOW_SIZE,
                              length=int(data_len[i])) for i in range(batch)]
    return raw_seqs


def stft(path, target_kz=None):
    arr, _ = librosa.load(path, target_kz)
    # very important padding
    arr_pad = librosa.util.fix_length(arr, len(arr) + WINDOW_SIZE // 2)
    return librosa.stft(arr_pad, n_fft=WINDOW_SIZE, hop_length=HOP_LENGTH, window='hann'), len(arr)


def aver_magnitude(dataloader, feature_size=129, set_='train'):
    dataset = dataloader(subset=set_)
    stream = dataset.read(batch=1, sortseq=True)
    total_mag = np.zeros((feature_size,))
    total_number = 0
    for k, data in enumerate(stream):
        inp, out, mask, length = data
        for i in range(len(length)):
            real = inp[i, :length[i], :feature_size]
            img = inp[i, :length[i], feature_size:]
            total_mag += np.sqrt(real ** 2 + img ** 2).mean(0)
        total_number += len(length)
        if k % 500 == 0:
            print("I'm at {}-th iterations".format(k))
    aver_mag = total_mag / total_number
    print ("average magnitude: {}".format(aver_mag))
    print ("total number of utterances: {}".format(total_number))
    return aver_mag


def complex_mul(source, mask):
    _, feature, _ = source.shape
    real = (source[:, :feature // 2] * mask[:, :feature // 2] -
            source[:, feature // 2:] * mask[:, feature // 2:])
    imag = (source[:, feature // 2:] * mask[:, :feature // 2] +
            source[:, :feature // 2] * mask[:, feature // 2:])
    return torch.cat([real, imag], dim=1)


def eval_sources(reference_mix, reference_sources,
                 estimated_sources, mask, sourcelen):
    batch, sources, feature, seq = reference_sources.shape
    estimated_raw = [istft(source, mask, sourcelen) for source in estimated_sources]
    reference_raw = [istft(reference_sources[:, i], mask, sourcelen)
                     for i in range(sources)]
    """for i in range(len(estimated_raw[0])):
        librosa.output.write_wav('estimated_raw_0_' + str(i) + '_.wav', estimated_raw[0][i], 8000)
        librosa.output.write_wav('estimated_raw_1_' + str(i) + '_.wav', estimated_raw[1][i], 8000)"""

    sdr_sum, sir_sum, sar_sum = 0, 0, 0
    for i in range(batch):
        concat_reference = np.vstack([source[i][None] for source in reference_raw])
        concat_estimate = np.vstack([source[i][None] for source in estimated_raw])
        (sdr, sir, sar, perm) = mir_eval.separation.bss_eval_sources(concat_reference,
                                                                     concat_estimate)
        sdr_sum += sdr.mean()
        sir_sum += sir.mean()
        sar_sum += sar.mean()
    return (sdr_sum / batch, sir_sum / batch, sar_sum / batch)
